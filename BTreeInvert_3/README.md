### Алгоритмическая сложность и затраты по памяти для метода `invert_tree`

#### Описание метода:
Метод `invert_tree` инвертирует двоичное дерево, то есть меняет местами левое и правое поддерево каждого узла. Он работает рекурсивно, проходя дерево по уровням, начиная с корня. Каждый узел посещается один раз, а его дети добавляются в список для дальнейшей инверсии.

#### Алгоритмическая сложность:
- **Время выполнения:** O(n)
  - Метод посещает каждый узел дерева ровно один раз, меняя местами левое и правое поддеревья. Поскольку количество узлов в дереве — это n, временная сложность будет линейной, то есть O(n).
  - Рекурсивный вызов метода выполняется для каждого уровня дерева, но на каждом уровне количество операций пропорционально количеству узлов на данном уровне. В сумме это всё равно приводит к линейной сложности.

#### Затраты по памяти:
- **Память:** O(n)
  - Для хранения списка текущих узлов (родителей) и их детей метод использует два списка — `parent_nodes` и `children_nodes`, которые могут содержать до n/2 элементов в случае полного дерева.
  - Дополнительная память на хранение рекурсивных вызовов зависит от высоты дерева. В худшем случае (для несбалансированного дерева) глубина рекурсии составит O(n) (если дерево представляет собой линейную структуру, например, список). В среднем же случае для сбалансированных деревьев глубина рекурсии составит O(log n), где n — количество узлов.
  - Таким образом, суммарные затраты по памяти составляют O(n) из-за хранения списка узлов и потенциальной глубины рекурсивного стека.
