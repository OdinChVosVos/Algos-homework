## 1. Метод revert_replacing(замена элементов без изменения направления связей):

Алгоритм перемещает зеркальные элементы на своих местах 
(например, 1-й элемент меняется местами с последним, 2-й — с предпоследним и т.д.).
Этот процесс занимает много шагов из-за обращения к элементам с использованием индекса.

**_Алгоритмическая сложность:_**

O(n^2)

Внутри каждого шага цикла алгоритм выполняет поиск родительских элементов (get_parent), что требует
O(n) для каждого вызова.

Основной цикл выполняется n/2 раз, но так как для каждого вызова требуется пройти по всему списку,
итоговая сложность O(n^2).

**_Затраты по памяти:_**

O(1)

Алгоритм использует только константное количество дополнительной памяти
(переменные для хранения текущих и вспомогательных указателей),
поскольку происходит модификация связей уже существующих узлов.


## 2. Метод revert_on_step (разворот направлений связей):
Алгоритм разворачивает ссылки каждого элемента на предыдущий, 
то есть изменяет направление указателей next каждого узла, проходя по списку.

**_Алгоритмическая сложность:_**

O(n)

Алгоритм проходит по каждому узлу только один раз, изменяя его указатель next на предыдущий узел.
Цикл выполняется n раз (где n — количество узлов в списке).

_**Затраты по памяти:**_ 

O(1)

Используется только константное количество дополнительной памяти для хранения указателей на предыдущий, текущий и следующий узлы.