# Алгоритмическая сложность и затраты по памяти

## Команда 1: Отображение индексов после сортировки по релевантности

### Описание
Команда 1 создает экземпляр класса `Relevance` и вызывает метод `get_relevance_sort_indexes()`, который сортирует список характеристик по релевантности.

### Алгоритмическая сложность
- **Сложность создания экземпляра класса `Relevance`:**
  - Итерация по `digit_characteristics` для добавления индексов: 
    - **O(d)**, где `d` — количество подсписков в `digit_characteristics`.
  
- **Сложность метода `get_relevance_sort_indexes()`:**
  - Сортировка списка `f` с использованием функции `sorted()`:
    - Сложность сортировки: **O(d log d)**, где `d` — количество подсписков.
  - Вычисление суммы для каждого подсписка:
    - Сложность вычисления суммы: **O(n)** для каждого подсписка, где `n` — длина списка `parameters`.
    - Таким образом, общая сложность для всех подсписков: **O(d * n)**.
  
- **Итоговая сложность**:
  - Общая сложность для команды 1: 
    $$ O(d \cdot n + d \log d) $$

### Затраты по памяти
- **Память для хранения параметров**:
  - Список `a`: **O(n)**.
- **Память для хранения характеристик**:
  - Список `f`: **O(d \cdot n)**.
- **Память для временной сортировки**:
  - Временная память, используемая при сортировке: **O(d)**.
  
- **Итоговые затраты по памяти**:
  - Общая память: 
    $$ O(n + d \cdot n) = O(d \cdot n) $$


## Команда 2: Изменение характеристик (f)

### Описание
Команда 2 изменяет значение в списке характеристик `f` на основе переданных индексов.

### Алгоритмическая сложность
- Доступ к элементу в списке и его изменение:
  - Сложность доступа к элементу: **O(1)**.
  
- **Итоговая сложность**:
  - Общая сложность для команды 2: 
    $$ O(1) $$

### Затраты по памяти
- Команда не требует дополнительных затрат по памяти, так как изменяет существующий список.

- **Итоговые затраты по памяти**:
  - Общая память: 
    $$ O(1) $$ (изменение значения не требует дополнительной памяти)